# ğŸ”§ Ghid React: Custom Hooks

> ÃnvaÈ›Äƒ cum sÄƒ creezi propriile tale hook-uri reutilizabile

---

## ğŸ“š Cuprins

1. [Ce sunt Custom Hooks?](#-ce-sunt-custom-hooks)
2. [Exemplu 1: usePosts - Fetch API](#-exemplu-1-useposts---fetch-api)
3. [Exemplu 2: useToggle - Comutare simpÄƒ](#-exemplu-2-usetoggle---comutare-simplÄƒ)
4. [Exemplu 3: useSimpleVote - Sistem de voturi](#-exemplu-3-usesimplevote---sistem-de-voturi)
5. [Exemplu 4: useLocalStorage - Salvare automatÄƒ](#-exemplu-4-uselocalstorage---salvare-automatÄƒ)

---

## ğŸ¯ Ce sunt Custom Hooks?

### Analogie: Kitul de Construit

**ImagineazÄƒ-È›i React Hooks ca piese LEGO:**

- `useState` = o piesÄƒ modularÄƒ standard
- `useEffect` = altÄƒ piesÄƒ standard
- **Custom Hook** = combini piese modulare Ã®ntr-o construcÈ›ie nouÄƒ pe care o reutilizezi oriunde ai nevoie

**Ca un set Lego standard** - creezi piese modulare o singurÄƒ datÄƒ, apoi le reutilizezi oriunde ai nevoie!

### De ce sÄƒ le folosim?

#### â™»ï¸ EvitÄƒ cod repetitiv

**FÄƒrÄƒ custom hook (repetitiv):**

```javascript
// Ãn 10 componente diferite, scrii acelaÈ™i cod:
function ComponentA() {
  const [posts, setPosts] = useState([]);
  
  useEffect(() => {
    axios.get('https://api.example.com/posts')
      .then(response => setPosts(response.data));
  }, []);
  
  return <div>{posts.map(...)}</div>;
}

// Ãn ComponentB - ACELAÈ˜I cod
// Ãn ComponentC - ACELAÈ˜I cod
// Ãn ComponentD - ACELAÈ˜I cod
// ... È™i aÈ™a mai departe ğŸ˜±
```

**Cu custom hook (o singurÄƒ datÄƒ):**

```javascript
// O singurÄƒ datÄƒ scrii:
function usePosts() {
  const [posts, setPosts] = useState([]);
  
  useEffect(() => {
    axios.get('https://api.example.com/posts')
      .then(response => setPosts(response.data));
  }, []);
  
  return posts;
}

// Ãn toate componentele - simplu:
function ComponentA() {
  const posts = usePosts();
  return <div>{posts.map(...)}</div>;
}

function ComponentB() {
  const posts = usePosts();
  return <div>{posts.map(...)}</div>;
}
```

#### ğŸ§© LogicÄƒ reutilizabilÄƒ

**ImportÄƒ È™i foloseÈ™te peste tot** - scrii logica o datÄƒ, o foloseÈ™ti Ã®n 100 de locuri!

#### ğŸ› ï¸ Mai uÈ™or de Ã®ntreÈ›inut

**ModificÄƒ Ã®ntr-un loc, se actualizeazÄƒ peste tot** - dacÄƒ schimbi API-ul, modifici doar custom hook-ul, nu 10 componente!

### Cum funcÈ›ioneazÄƒ?

**Custom hooks:**
- ConÈ›in React hooks (useState, useEffect, etc.)
- **NU returneazÄƒ JSX/HTML** - returneazÄƒ doar date
- Numele Ã®ncepe cu `use` (obligatoriu!)
- Extrage logicÄƒ comunÄƒ

---

## ğŸ“¡ Exemplu 1: usePosts - Fetch API

### Problema

**Trebuie sÄƒ preluÄƒm date de la server Ã®n mai multe componente.**

### SoluÈ›ia: usePosts

```javascript
// FiÈ™ier: usePosts.js
import axios from "axios";
import { useEffect, useState } from "react";

export function usePosts() {
  const [posts, setPosts] = useState([]);

  useEffect(() => {
    axios.get("https://jsonplaceholder.typicode.com/posts")
      .then((response) => {
        setPosts(response.data);
      });
  }, []);

  return posts;
}
```

### ExplicaÈ›ie pas cu pas

#### 1. Crearea hook-ului

```javascript
export function usePosts() {
  // Logica aici
}
```

**Cine apeleazÄƒ funcÈ›ia `usePosts`?**
- **TU** o apelez manual Ã®n componente: `const posts = usePosts();`
- Nu React, nu browser-ul - TU decizi cÃ¢nd È™i unde

#### 2. State pentru posts

```javascript
const [posts, setPosts] = useState([]);
```

**Ce se Ã®ntÃ¢mplÄƒ:**
- Creezi state local Ã®n hook
- Fiecare componentÄƒ care foloseÈ™te `usePosts()` are propriul sÄƒu state separat
- `posts` = array gol la Ã®nceput
- `setPosts` = funcÈ›ia care actualizeazÄƒ array-ul

**Cine apeleazÄƒ `useState`?**
- **React** o apeleazÄƒ automat cÃ¢nd hook-ul se executÄƒ

#### 3. Fetch la mount

```javascript
useEffect(() => {
  axios.get("https://jsonplaceholder.typicode.com/posts")
    .then((response) => {
      setPosts(response.data);
    });
}, []);
```

**Ce se Ã®ntÃ¢mplÄƒ:**

```
1. Hook-ul usePosts() se executÄƒ
   â†“
2. useEffect ruleazÄƒ (array gol [] = o singurÄƒ datÄƒ)
   â†“
3. axios.get trimite cerere la server
   â†“
4. Server rÄƒspunde cu lista de posts
   â†“
5. .then primeÈ™te rÄƒspunsul
   â†“
6. setPosts(response.data) actualizeazÄƒ state-ul
   â†“
7. Hook-ul returneazÄƒ posts actualizate
```

**Cine apeleazÄƒ `.then()`?**
- **Axios** o apeleazÄƒ automat cÃ¢nd primeÈ™te rÄƒspuns de la server
- Tu doar defineÈ™ti ce sÄƒ facÄƒ, axios decide cÃ¢nd

#### 4. Returnarea datelor

```javascript
return posts;
```

**Ce returneazÄƒ:**
- La Ã®nceput: `[]` (array gol)
- DupÄƒ fetch: `[{post1}, {post2}, ...]` (array cu posts)

### Folosire Ã®n componentÄƒ

```javascript
import { usePosts } from './usePosts';

export function Posts() {
  const posts = usePosts();
  
  return (
    <div>
      {posts.map((post) => (
        <div key={post.id}>{post.title}</div>
      ))}
    </div>
  );
}
```

**Fluxul complet:**

```
1. Componenta Posts se randeazÄƒ
   â†“
2. TU apelez: const posts = usePosts();
   â†“
3. usePosts() se executÄƒ:
   - useState([]) â†’ posts = []
   - useEffect trimite cerere axios
   - return posts (Ã®ncÄƒ [])
   â†“
4. Componenta afiÈ™eazÄƒ lista goalÄƒ (deocamdatÄƒ)
   â†“
5. Axios primeÈ™te rÄƒspuns de la server
   â†“
6. .then apeleazÄƒ setPosts(response.data)
   â†“
7. State-ul se schimbÄƒ â†’ posts devine [{...}, {...}]
   â†“
8. React redeseneazÄƒ componenta
   â†“
9. usePosts() se executÄƒ din nou
   â†“
10. return posts (acum cu date!)
   â†“
11. map() afiÈ™eazÄƒ toate posts-urile
```

**Ce returneazÄƒ:**
- Date aduse de la server

---

## ğŸ”„ Exemplu 2: useToggle - Comutare simplÄƒ

### Problema

**Trebuie sÄƒ comutÄƒm Ã®ntre true/false Ã®n mai multe locuri.**

### SoluÈ›ia: useToggle

```javascript
// FiÈ™ier: useToggle.js
import { useState } from "react";

export function useToggle(initialValue) {
  const [value, setValue] = useState(initialValue);

  function toggleValue() {
    setValue(!value);
  }

  return [value, toggleValue];
}
```

### ExplicaÈ›ie pas cu pas

#### 1. Parametrul initialValue

```javascript
export function useToggle(initialValue) {
  // initialValue = valoarea de start (true sau false)
}
```

**Cine trimite `initialValue`?**
- **TU** cÃ¢nd apelez hook-ul: `useToggle(false)`
- Decizi tu valoarea iniÈ›ialÄƒ

#### 2. State pentru value

```javascript
const [value, setValue] = useState(initialValue);
```

**Exemplu:**
```javascript
// DacÄƒ apelez useToggle(false):
const [value, setValue] = useState(false);
// value = false
```

#### 3. FuncÈ›ia toggleValue

```javascript
function toggleValue() {
  setValue(!value);
}
```

**Ce face:**
- `!value` = inverseazÄƒ valoarea
- `!false` â†’ `true`
- `!true` â†’ `false`

**Cine apeleazÄƒ `toggleValue`?**
- **TU** o apelez manual cÃ¢nd vrei sÄƒ comiÈ›i: `toggle()`
- Nu se apeleazÄƒ automat - tu decizi cÃ¢nd

**Exemplu:**
```javascript
// value = false
toggleValue();  // TU apelez
// setValue(!false) â†’ setValue(true)
// value = true

toggleValue();  // TU apelez din nou
// setValue(!true) â†’ setValue(false)
// value = false
```

#### 4. Returnarea array-ului

```javascript
return [value, toggleValue];
```

**De ce array?**
- AcelaÈ™i pattern ca `useState`
- PoÈ›i denumi cum vrei la destructuring

### Folosire Ã®n componentÄƒ

```javascript
import { useToggle } from './useToggle';

export function Menu() {
  const [isOpen, toggle] = useToggle(false);
  
  return (
    <div>
      <button onClick={toggle}>
        {isOpen ? 'Ãnchide' : 'Deschide'}
      </button>
      
      {isOpen && <div>Meniu deschis!</div>}
    </div>
  );
}
```

**Fluxul complet:**

```
1. Componenta Menu se randeazÄƒ
   â†“
2. TU apelez: const [isOpen, toggle] = useToggle(false);
   â†“
3. useToggle(false) se executÄƒ:
   - useState(false) â†’ value = false
   - toggleValue = funcÈ›ia creatÄƒ
   - return [false, toggleValue]
   â†“
4. isOpen = false
5. toggle = toggleValue
   â†“
6. Componenta afiÈ™eazÄƒ: "Deschide"
   â†“
7. User dÄƒ click pe buton
   â†“
8. onClick={toggle} â†’ TU (prin click) apelez toggle()
   â†“
9. toggle() = toggleValue()
   â†“
10. setValue(!false) â†’ setValue(true)
   â†“
11. React redeseneazÄƒ componenta
   â†“
12. isOpen = true
   â†“
13. Componenta afiÈ™eazÄƒ: "Ãnchide" È™i meniul
```

**Ce returneazÄƒ:**
- `[value, toggleValue]` - valoarea curentÄƒ È™i funcÈ›ia de comutare

---

## ğŸ‘ Exemplu 3: useSimpleVote - Sistem de voturi

### Problema

**Trebuie sÄƒ implementÄƒm sistem de voturi (upvote/downvote) Ã®n mai multe locuri.**

### SoluÈ›ia: useSimpleVote

```javascript
// FiÈ™ier: useSimpleVote.js
import { useState } from "react";

export function useSimpleVote(initialValue) {
  const [votes, setVotes] = useState(initialValue);

  const upVote = () => {
    setVotes(votes + 1);
  };

  const downVote = () => {
    setVotes(votes - 1);
  };

  return { votes, upVote, downVote };
}
```

### ExplicaÈ›ie pas cu pas

#### 1. State pentru votes

```javascript
const [votes, setVotes] = useState(initialValue);
```

**Exemplu:**
```javascript
// DacÄƒ apelez useSimpleVote(15):
const [votes, setVotes] = useState(15);
// votes = 15
```

#### 2. FuncÈ›ia upVote

```javascript
const upVote = () => {
  setVotes(votes + 1);
};
```

**Ce face:**
- CreÈ™te numÄƒrul de voturi cu 1

**Cine apeleazÄƒ `upVote`?**
- **TU** o apelez manual cÃ¢nd user-ul dÄƒ click: `upVote()`

**Exemplu:**
```javascript
// votes = 15
upVote();  // TU apelez
// setVotes(15 + 1) â†’ setVotes(16)
// votes = 16
```

#### 3. FuncÈ›ia downVote

```javascript
const downVote = () => {
  setVotes(votes - 1);
};
```

**Ce face:**
- Scade numÄƒrul de voturi cu 1

**Cine apeleazÄƒ `downVote`?**
- **TU** o apelez manual cÃ¢nd user-ul dÄƒ click: `downVote()`

**Exemplu:**
```javascript
// votes = 16
downVote();  // TU apelez
// setVotes(16 - 1) â†’ setVotes(15)
// votes = 15
```

#### 4. Returnarea obiectului

```javascript
return { votes, upVote, downVote };
```

**De ce obiect?**
- Mai clar decÃ¢t array
- Numele sunt fixe (nu poÈ›i schimba)
- Destructuring cu nume exacte

### Folosire Ã®n componentÄƒ

```javascript
import { useSimpleVote } from './useSimpleVote';

export function Post() {
  const { votes, upVote, downVote } = useSimpleVote(15);
  
  return (
    <div>
      <button onClick={upVote}>ğŸ‘ Upvote</button>
      <span>{votes} voturi</span>
      <button onClick={downVote}>ğŸ‘ Downvote</button>
    </div>
  );
}
```

**Fluxul complet:**

```
1. Componenta Post se randeazÄƒ
   â†“
2. TU apelez: const { votes, upVote, downVote } = useSimpleVote(15);
   â†“
3. useSimpleVote(15) se executÄƒ:
   - useState(15) â†’ votes = 15
   - upVote = funcÈ›ia creatÄƒ
   - downVote = funcÈ›ia creatÄƒ
   - return { votes: 15, upVote, downVote }
   â†“
4. votes = 15
5. upVote = funcÈ›ia
6. downVote = funcÈ›ia
   â†“
7. Componenta afiÈ™eazÄƒ: "15 voturi"
   â†“
8. User dÄƒ click pe ğŸ‘ Upvote
   â†“
9. onClick={upVote} â†’ TU (prin click) apelez upVote()
   â†“
10. upVote()
   â†“
11. setVotes(15 + 1) â†’ setVotes(16)
   â†“
12. React redeseneazÄƒ componenta
   â†“
13. votes = 16
   â†“
14. Componenta afiÈ™eazÄƒ: "16 voturi"
```

**Ce returneazÄƒ:**
- Obiect cu `votes`, `upVote`, `downVote`

---

## ğŸ’¾ Exemplu 4: useLocalStorage - Salvare automatÄƒ

### Problema

**Trebuie sÄƒ salvÄƒm date Ã®n localStorage È™i sÄƒ le sincronizÄƒm cu state-ul.**

### Ce este localStorage?

**Browser storage** - salveazÄƒ date Ã®n browser care persistÄƒ dupÄƒ refresh

**Analogie:** E ca un sertar Ã®n browser unde poÈ›i pÄƒstra lucruri È™i rÄƒmÃ¢n acolo chiar È™i dupÄƒ ce Ã®nchizi pagina!

### SoluÈ›ia: useLocalStorage

```javascript
// FiÈ™ier: useLocalStorage.js
import { useState } from "react";

export function useLocalStorage(key, defaultValue) {
  function getDefaultValue() {
    const localValue = localStorage.getItem(key);
    
    if (localValue) return localValue;
    
    return defaultValue;
  }

  const [value, setValue] = useState(getDefaultValue());

  function setLocalStorageValue(updatedValue) {
    setValue(updatedValue);
    localStorage.setItem(key, updatedValue);
  }

  return [value, setLocalStorageValue];
}
```

### ExplicaÈ›ie pas cu pas

#### 1. VerificÄƒ localStorage

```javascript
function getDefaultValue() {
  const localValue = localStorage.getItem(key);
  
  if (localValue) return localValue;
  
  return defaultValue;
}
```

**Ce face:**

```
1. CautÄƒ cheia specificatÄƒ Ã®n localStorage
   â†“
2. DacÄƒ existÄƒ â†’ returneazÄƒ valoarea salvatÄƒ
   â†“
3. DacÄƒ NU existÄƒ â†’ returneazÄƒ valoarea default
```

**Cine apeleazÄƒ `getDefaultValue`?**
- **useState** o apeleazÄƒ automat cÃ¢nd iniÈ›ializeazÄƒ state-ul

**Exemplu:**
```javascript
// Prima datÄƒ (localStorage gol):
localStorage.getItem('theme') â†’ null
return defaultValue â†’ 'light'

// A doua oarÄƒ (dupÄƒ salvare):
localStorage.getItem('theme') â†’ 'dark'
return 'dark'
```

#### 2. ParseazÄƒ datele

```javascript
const localValue = localStorage.getItem(key);
```

**localStorage salveazÄƒ doar STRING-uri:**
```javascript
// SalveazÄƒ
localStorage.setItem('count', '42');

// CiteÈ™te
localStorage.getItem('count') â†’ '42' (string, nu numÄƒr!)
```

**De aceea conversie:**
```javascript
// DacÄƒ lucrezi cu numere:
const count = Number(localStorage.getItem('count'));

// DacÄƒ lucrezi cu obiecte:
const user = JSON.parse(localStorage.getItem('user'));
```

#### 3. IniÈ›ializeazÄƒ state-ul

```javascript
const [value, setValue] = useState(getDefaultValue());
```

**Ce se Ã®ntÃ¢mplÄƒ:**

```
1. useState apeleazÄƒ getDefaultValue()
   â†“
2. getDefaultValue verificÄƒ localStorage
   â†“
3. ReturneazÄƒ valoarea gÄƒsitÄƒ sau default
   â†“
4. useState iniÈ›ializeazÄƒ cu acea valoare
```

**Cine apeleazÄƒ `useState`?**
- **React** o apeleazÄƒ automat cÃ¢nd hook-ul se executÄƒ

#### 4. ActualizeazÄƒ sincron

```javascript
function setLocalStorageValue(updatedValue) {
  setValue(updatedValue);
  localStorage.setItem(key, updatedValue);
}
```

**Ce face:**

```
1. setValue(updatedValue) â†’ actualizeazÄƒ state-ul React
   â†“
2. localStorage.setItem(key, updatedValue) â†’ salveazÄƒ Ã®n browser
```

**Ambele se Ã®ntÃ¢mplÄƒ SIMULTAN** - de aceea "sincron"!

**Cine apeleazÄƒ `setLocalStorageValue`?**
- **TU** o apelez manual cÃ¢nd vrei sÄƒ actualizezi: `setTheme('dark')`

**Exemplu:**
```javascript
// User schimbÄƒ tema la dark
setLocalStorageValue('dark');

// Se Ã®ntÃ¢mplÄƒ:
// 1. setValue('dark') â†’ React actualizeazÄƒ state
// 2. localStorage.setItem('theme', 'dark') â†’ Browser salveazÄƒ
```

#### 5. Returnarea array-ului

```javascript
return [value, setLocalStorageValue];
```

**AcelaÈ™i pattern ca useState** - destructurezi cum vrei

### Folosire Ã®n componentÄƒ

```javascript
import { useLocalStorage } from './useLocalStorage';

export function ThemeSwitcher() {
  const [theme, setTheme] = useLocalStorage('theme', 'light');
  
  return (
    <div>
      <p>Tema curentÄƒ: {theme}</p>
      <button onClick={() => setTheme('dark')}>Dark</button>
      <button onClick={() => setTheme('light')}>Light</button>
    </div>
  );
}
```

**Fluxul complet:**

```
PRIMA ÃNCÄ‚RCARE (localStorage gol):
1. Componenta se randeazÄƒ
   â†“
2. TU apelez: const [theme, setTheme] = useLocalStorage('theme', 'light');
   â†“
3. useLocalStorage('theme', 'light') se executÄƒ:
   â†“
4. useState apeleazÄƒ getDefaultValue():
   - localStorage.getItem('theme') â†’ null
   - return 'light'
   â†“
5. useState('light') â†’ theme = 'light'
   â†“
6. setLocalStorageValue = funcÈ›ia creatÄƒ
   â†“
7. return ['light', setLocalStorageValue]
   â†“
8. Componenta afiÈ™eazÄƒ: "Tema curentÄƒ: light"

USER DÄ‚ CLICK PE "Dark":
9. onClick={() => setTheme('dark')} â†’ TU apelez setTheme('dark')
   â†“
10. setTheme = setLocalStorageValue
   â†“
11. setLocalStorageValue('dark'):
    - setValue('dark') â†’ theme = 'dark'
    - localStorage.setItem('theme', 'dark') â†’ salvat Ã®n browser
   â†“
12. React redeseneazÄƒ componenta
   â†“
13. theme = 'dark'
   â†“
14. Componenta afiÈ™eazÄƒ: "Tema curentÄƒ: dark"

USER REÃNCARCÄ‚ PAGINA:
15. Componenta se randeazÄƒ din nou
   â†“
16. useLocalStorage('theme', 'light') se executÄƒ
   â†“
17. useState apeleazÄƒ getDefaultValue():
    - localStorage.getItem('theme') â†’ 'dark' (salvat anterior!)
    - return 'dark'
   â†“
18. useState('dark') â†’ theme = 'dark'
   â†“
19. Componenta afiÈ™eazÄƒ: "Tema curentÄƒ: dark" (persistent!)
```

**Ce returneazÄƒ:**
- Array cu valoarea curentÄƒ È™i funcÈ›ia de actualizare (sincronizatÄƒ cu localStorage)

---

## ğŸ¯ Recapitulare

### Ce sunt Custom Hooks?

**FuncÈ›ii care:**
- Ãncep cu `use`
- ConÈ›in React hooks (useState, useEffect)
- **NU returneazÄƒ JSX** - doar date
- Extrag logicÄƒ reutilizabilÄƒ

### Cele 4 exemple

| Hook | Ce face | Ce returneazÄƒ |
|------|---------|---------------|
| **usePosts** | Fetch date de la API | Array de posts |
| **useToggle** | ComutÄƒ true/false | `[value, toggle]` |
| **useSimpleVote** | Sistem de voturi | `{ votes, upVote, downVote }` |
| **useLocalStorage** | Salvare automatÄƒ | `[value, setValue]` |

### Cine apeleazÄƒ ce?

| FuncÈ›ie | Cine apeleazÄƒ |
|---------|---------------|
| **Custom Hook** (`usePosts()`) | **TU** - manual Ã®n componentÄƒ |
| **useState** | **React** - automat cÃ¢nd hook se executÄƒ |
| **useEffect** | **React** - automat la mount/update |
| **axios.then()** | **Axios** - automat cÃ¢nd primeÈ™te rÄƒspuns |
| **toggleValue()** | **TU** - manual la click |
| **upVote()** | **TU** - manual la click |
| **setLocalStorageValue()** | **TU** - manual cÃ¢nd vrei sÄƒ salvezi |

### Structura fiÈ™ierelor

```
src/
  hooks/
    usePosts.js          â† .js (nu .jsx!)
    useToggle.js
    useSimpleVote.js
    useLocalStorage.js
  components/
    Posts.jsx            â† .jsx
    Menu.jsx
```

**De reÈ›inut:**
- Hook-uri = `.js` (doar logicÄƒ)
- Componente = `.jsx` (JSX/HTML)

---

## ğŸ‰ FelicitÄƒri!

Acum È™tii:
- âœ… Ce sunt custom hooks
- âœ… De ce sÄƒ le foloseÈ™ti
- âœ… Cum sÄƒ creezi usePosts pentru API
- âœ… Cum sÄƒ creezi useToggle pentru comutare
- âœ… Cum sÄƒ creezi useSimpleVote pentru voturi
- âœ… Cum sÄƒ creezi useLocalStorage pentru persistenÈ›Äƒ
- âœ… Cine apeleazÄƒ fiecare funcÈ›ie