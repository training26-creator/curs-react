# React: Styling, Evenimente È™i State

> ÃnvaÈ›Äƒ cum sÄƒ stilizezi componente, sÄƒ gestionezi evenimente È™i sÄƒ foloseÈ™ti state Ã®n React

---

## ğŸ“š Cuprins

1. [className È™i style Ã®n JSX](#-classname-È™i-style-Ã®n-jsx)
2. [Evenimente Ã®n React](#-evenimente-Ã®n-react)
3. [useState - Memoria Componentei](#-usestate---memoria-componentei)
4. [Recapitulare](#-recapitulare)

---

## ğŸ¨ className È™i style Ã®n JSX

### De ce sunt diferite?

**ImagineazÄƒ-È›i cÄƒ HTML È™i JavaScript sunt doi colegi de camerÄƒ.**

CÃ¢nd amÃ¢ndoi vor sÄƒ foloseascÄƒ acelaÈ™i cuvÃ¢nt, HTML cedeazÄƒ politicos È™i Ã®È™i gÄƒseÈ™te un sinonim.

### class â†’ className

```jsx
// âŒ HTML normal (nu funcÈ›ioneazÄƒ Ã®n React):
<div class="container"></div>

// âœ… JSX (React):
<div className="container"></div>
```

**De ce schimbarea?**
- CuvÃ¢ntul `class` e rezervat Ã®n JavaScript pentru clase (OOP)
- React foloseÈ™te `className` sÄƒ nu creeze confuzie

**Exemplu practic:**

```jsx
export function HtmlFor() {
  return (
    <div>
      <label htmlFor="x">Prenume:</label>
      <input id="x" type="text" className="input-field" />
    </div>
  );
}
```

### for â†’ htmlFor

```jsx
// âŒ HTML normal:
<label for="username">Nume:</label>

// âœ… JSX (React):
<label htmlFor="username">Nume:</label>
```

**De ce?**
- `for` e cuvÃ¢nt rezervat Ã®n JavaScript (pentru bucle: `for (let i = 0; i < 10; i++)`)
- React foloseÈ™te `htmlFor` pentru a evita conflictul

### style - De la string la obiect

**Ãn HTML clasic, style este un string:**

```html
<div style="background-color: red; font-size: 20px;"></div>
```

**Ãn React, style este un OBIECT JavaScript:**

```jsx
<div style={{
  backgroundColor: "red",
  fontSize: "20px"
}}></div>
```

**ExplicaÈ›ie pas cu pas:**

1. **DouÄƒ acolade `{{}}`**
   - Prima `{}` = spune "Aici e JavaScript!"
   - A doua `{}` = obiectul JavaScript propriu-zis

2. **ProprietÄƒÈ›ile CSS devin camelCase**
   - `background-color` â†’ `backgroundColor`
   - `font-size` â†’ `fontSize`
   - `border-radius` â†’ `borderRadius`

**De ce camelCase?**
- Ãn JavaScript, liniuÈ›ele `-` nu sunt permise Ã®n numele proprietÄƒÈ›ilor
- `background-color` nu e valid, dar `backgroundColor` e perfect

**Exemplu complet din codul nostru:**

```jsx
export function HtmlFor() {
  return (
    <div
      style={{
        backgroundColor: "red",
      }}
    >
      <label htmlFor="x">Prenume:</label>
      <input id="x" type="text" />
      <hr />
    </div>
  );
}
```

**Ce se Ã®ntÃ¢mplÄƒ aici:**

1. **`style={{ backgroundColor: "red" }}`**
   - DouÄƒ acolade: prima pentru JSX, a doua pentru obiect
   - Creezi un obiect JavaScript: `{ backgroundColor: "red" }`
   - React transformÄƒ asta Ã®n CSS pentru browser

2. **`htmlFor="x"`**
   - LeagÄƒ label-ul de input
   - CÃ¢nd dai click pe "Prenume:", cursorul merge Ã®n input cu `id="x"`

3. **Fluxul complet:**
   ```
   User vede: Label "Prenume:" È™i un input cu fundal roÈ™u
   User dÄƒ click pe "Prenume:"
   Browser: "Ah, htmlFor='x' Ã®nseamnÄƒ input cu id='x'"
   Cursorul apare Ã®n input
   ```

### ğŸ¯ Rezumat rapid

| HTML Clasic | JSX (React) | Motiv |
|-------------|-------------|-------|
| `class` | `className` | `class` e rezervat Ã®n JS |
| `for` | `htmlFor` | `for` e rezervat Ã®n JS |
| `style="color: red"` | `style={{ color: "red" }}` | JSX foloseÈ™te obiecte JS |
| `background-color` | `backgroundColor` | ProprietÄƒÈ›i JS sunt camelCase |

---

## ğŸª Evenimente Ã®n React

### Ce sunt evenimentele?

**GÃ¢ndeÈ™te-te la evenimente ca la o sonerie:**
- CÃ¢nd cineva apasÄƒ butonul (evenimentul), tu reacÈ›ionezi deschizÃ¢nd uÈ™a (funcÈ›ia).
- Ãn React, soneria e pusÄƒ DIRECT pe buton!

### Adio `addEventListener`! ğŸ‘‹

**Ãn JavaScript vanilla (normal):**

```javascript
// Pasul 1: GÄƒseÈ™ti elementul
const button = document.getElementById("myButton");

// Pasul 2: Adaugi event listener
button.addEventListener("click", function() {
  console.log("Butonul a fost apÄƒsat!");
});
```

**Ãn React:**

```jsx
// Totul Ã®ntr-un singur loc!
<button onClick={handleClick}>ApasÄƒ-mÄƒ</button>
```

**De ce e mai bine?**
- Mai simplu, mai curat, totul Ã®n acelaÈ™i loc
- Nu trebuie sÄƒ cauÈ›i elemente Ã®n DOM
- React se ocupÄƒ automat de curÄƒÈ›enie cÃ¢nd componenta dispare

### Cele mai folosite evenimente

#### 1ï¸âƒ£ onClick - Click-ul È™oricelului ğŸ–±ï¸

```jsx
export function Click() {
  function handleClick() {
    console.log("Userul a dat click");
  }

  return <button onClick={handleClick}>Apasa</button>;
}
```

**ExplicaÈ›ie pas cu pas:**

1. **`function handleClick()`**
   - Creezi o funcÈ›ie care se va executa la click
   - Nu o apelezi TU manual - React o va apela

2. **`onClick={handleClick}`**
   - TrimiÈ›i REFERINÈšA funcÈ›iei (fÄƒrÄƒ paranteze `()`)
   - âŒ GreÈ™it: `onClick={handleClick()}` - asta o apeleazÄƒ IMEDIAT
   - âœ… Corect: `onClick={handleClick}` - asta o trimite lui React sÄƒ o apeleze mai tÃ¢rziu

3. **CÃ¢nd se executÄƒ?**
   - React pÄƒstreazÄƒ funcÈ›ia
   - CÃ¢nd userul dÄƒ click, React apeleazÄƒ: `handleClick()`

**Cine apeleazÄƒ `handleClick`?**
- **React** o apeleazÄƒ automat cÃ¢nd detecteazÄƒ click-ul
- Tu doar dai "reÈ›eta", React o executÄƒ

**Fluxul complet:**
```
1. Componenta se Ã®ncarcÄƒ
   â†“
2. React vede onClick={handleClick}
   â†“
3. React salveazÄƒ: "CÃ¢nd e click, apeleazÄƒ handleClick"
   â†“
4. User dÄƒ click pe buton
   â†“
5. Browser detecteazÄƒ click-ul
   â†“
6. React primeÈ™te notificarea
   â†“
7. React apeleazÄƒ: handleClick()
   â†“
8. Console-ul afiÈ™eazÄƒ: "Userul a dat click"
```

#### 2ï¸âƒ£ onScroll - Derulare ğŸ“œ

```jsx
export function Scroll() {
  function handleScroll() {
    console.log("Userul deruleazÄƒ pagina");
  }

  return <div onScroll={handleScroll}>ConÈ›inut lung...</div>;
}
```

**CÃ¢nd se foloseÈ™te:**
- Detectare scroll infinit (ca pe Instagram sau Facebook)
- AfiÈ™are buton "Ãnapoi sus" cÃ¢nd scroll-ezi
- AnimaÈ›ii care apar cÃ¢nd scroll-ezi

#### 3ï¸âƒ£ onChange - Input modificat âŒ¨ï¸

```jsx
export function Input() {
  function handleChange(event) {
    console.log("Tastat:", event.target.value);
  }
  
  return <input type="text" onChange={handleChange} />;
}
```

**ExplicaÈ›ie detaliatÄƒ:**

1. **`function handleChange(event)`**
   - FuncÈ›ia primeÈ™te automat un parametru: `event`
   - `event` = obiect cu informaÈ›ii despre ce s-a Ã®ntÃ¢mplat

2. **`event.target.value`**
   - `event.target` = elementul care a declanÈ™at evenimentul (input-ul)
   - `.value` = textul scris Ã®n input

3. **CÃ¢nd se executÄƒ?**
   - De fiecare datÄƒ cÃ¢nd scrii o literÄƒ Ã®n input
   - React apeleazÄƒ: `handleChange(eventObject)`

**Cine apeleazÄƒ `handleChange`?**
- **React** o apeleazÄƒ automat cÃ¢nd detecteazÄƒ modificarea Ã®n input
- **React** creeazÄƒ obiectul `event` È™i Ã®l trimite funcÈ›iei tale

**Exemplu pas cu pas:**

```
User scrie "a" â†’ React apeleazÄƒ handleChange(event)
                â†’ event.target.value = "a"
                â†’ Console: "Tastat: a"

User scrie "b" â†’ React apeleazÄƒ handleChange(event)
                â†’ event.target.value = "ab"
                â†’ Console: "Tastat: ab"

User scrie "c" â†’ React apeleazÄƒ handleChange(event)
                â†’ event.target.value = "abc"
                â†’ Console: "Tastat: abc"
```

**Fluxul complet:**
```
User scrie "H"
   â†“
Input-ul se modificÄƒ
   â†“
Browser detecteazÄƒ modificarea
   â†“
React primeÈ™te notificarea
   â†“
React creeazÄƒ obiectul event: { target: { value: "H" } }
   â†“
React apeleazÄƒ: handleChange(event)
   â†“
Console: "Tastat: H"

User scrie "e" (acum e "He")
   â†“
React apeleazÄƒ: handleChange(event)
   â†“
Console: "Tastat: He"

User scrie "l" (acum e "Hel")
   â†“
React apeleazÄƒ: handleChange(event)
   â†“
Console: "Tastat: Hel"
```

### ğŸ¯ Regula de aur pentru evenimente

```jsx
// âœ… CORECT - Trimite referinÈ›a:
<button onClick={handleClick}>Click</button>

// âŒ GREÈ˜IT - ApeleazÄƒ funcÈ›ia IMEDIAT (fÄƒrÄƒ sÄƒ vrei):
<button onClick={handleClick()}>Click</button>

// âœ… CORECT - DacÄƒ vrei sÄƒ trimiÈ›i parametri, foloseÈ™te funcÈ›ie arrow:
<button onClick={() => handleClick("parametru")}>Click</button>
```

### ğŸ“Š Tabel evenimente HTML â†’ React

| HTML | React | Folosit pentru |
|------|-------|----------------|
| `onclick` | `onClick` | Click mouse |
| `onchange` | `onChange` | Input modificat |
| `onsubmit` | `onSubmit` | Trimitere formular |
| `onscroll` | `onScroll` | Derulare paginÄƒ |
| `onmouseover` | `onMouseOver` | Mouse peste element |
| `onkeydown` | `onKeyDown` | TastÄƒ apÄƒsatÄƒ |

**Regula:** Toate evenimentele din React sunt **camelCase** (prima literÄƒ micÄƒ, restul cuvintelor cu majusculÄƒ).

---

## ğŸ’¾ useState - Memoria Componentei

### Ce este state-ul?

**State-ul e ca un Ã®ntrerupÄƒtor de luminÄƒ: poate fi pornit sau oprit.**

CÃ¢nd Ã®l apeÈ™i (modifici state-ul), camera (componenta) se schimbÄƒ instant!

### Problema fÄƒrÄƒ useState

**GÃ¢ndeÈ™te-te la asta ca la o poveste:**

```jsx
export function Test() {
  let value = 0;  // VariabilÄƒ normalÄƒ

  function handleClick() {
    value = value + 1;  // Schimb valoarea
    console.log(value); // AfiÈ™eazÄƒ 1, 2, 3...
  }

  return <button onClick={handleClick}>Clicked: {value}</button>;
  // Problema: Pe ecran rÄƒmÃ¢ne mereu 0! ğŸ˜±
}
```

**Ce se Ã®ntÃ¢mplÄƒ?**
1. Dai click â†’ `value` devine 1
2. Console-ul afiÈ™eazÄƒ: `1` âœ…
3. DAR pe ecran tot `0` apare! âŒ

**De ce?**
- React nu È™tie cÄƒ `value` s-a schimbat
- React nu redeseneazÄƒ componenta
- E ca È™i cum ai schimba mobila Ã®n camerÄƒ, dar nimeni nu vede pentru cÄƒ luminile sunt stinse!

### SoluÈ›ia: useState

**useState e ca un semafor care spune React-ului: "AtenÈ›ie, ceva s-a schimbat, redeseneazÄƒ!"**

```jsx
import { useState } from "react";

export function State() {
  const [value, setValue] = useState(0);

  function handleClick() {
    setValue(value + 1);
  }

  return <button onClick={handleClick}>Clicked: {value}</button>;
  // Acum funcÈ›ioneazÄƒ perfect! ğŸ‰
}
```

### Cum funcÈ›ioneazÄƒ useState pas cu pas

#### Pasul 1: ImportÄƒ hook-ul

```jsx
import { useState } from "react";
```

**Ce Ã®nseamnÄƒ "hook"?**
- Orice funcÈ›ie din React care Ã®ncepe cu `use` = hook
- `useState`, `useEffect`, `useContext` - toate sunt hook-uri
- Hook-urile dau "superputeri" componentelor tale

#### Pasul 2: DeclarÄƒ state-ul

```jsx
const [value, setValue] = useState(0);
```

**Anatomia acestei linii:**

```jsx
const [value, setValue] = useState(0);
      â†‘      â†‘              â†‘        â†‘
      â”‚      â”‚              â”‚        â”‚
   citesc  modific      funcÈ›ia   valoarea
   state   state-ul     React    iniÈ›ialÄƒ
```

**ExplicaÈ›ie detaliatÄƒ:**

1. **`useState(0)`**
   - Apelezi funcÈ›ia `useState` cu valoarea iniÈ›ialÄƒ `0`
   - React creeazÄƒ un "slot" de memorie pentru aceastÄƒ componentÄƒ

2. **`[value, setValue]`**
   - `useState` returneazÄƒ un array cu 2 elemente
   - Primul element (`value`) = valoarea curentÄƒ
   - Al doilea element (`setValue`) = funcÈ›ia care schimbÄƒ valoarea

3. **Destructuring**
   ```jsx
   // FÄƒrÄƒ destructuring (complicat):
   const stateArray = useState(0);
   const value = stateArray[0];
   const setValue = stateArray[1];

   // Cu destructuring (simplu):
   const [value, setValue] = useState(0);
   ```

#### Pasul 3: FoloseÈ™te È™i actualizeazÄƒ state-ul

```jsx
function handleClick() {
  setValue(value + 1);  // ModificÄƒ state-ul
}

return <button onClick={handleClick}>Clicked: {value}</button>;
```

**Ce se Ã®ntÃ¢mplÄƒ cÃ¢nd apeÈ™i butonul:**

```
1. User dÄƒ click
   â†“
2. React apeleazÄƒ handleClick()
   â†“
3. handleClick apeleazÄƒ setValue(value + 1)
   â†“
4. React primeÈ™te noua valoare
   â†“
5. React spune: "State-ul s-a schimbat, redesenez componenta!"
   â†“
6. React apeleazÄƒ din nou funcÈ›ia State() cu noua valoare
   â†“
7. Componenta se redeseneazÄƒ cu valoarea nouÄƒ
   â†“
8. Pe ecran apare noul numÄƒr! ğŸ‰
```

### ğŸ”„ Fluxul complet cu exemplu din cod

```jsx
import { useState } from "react";

export function State() {
  const [value, setValue] = useState(0);

  function handleClick() {
    setValue(value + 1);
  }

  console.log(value, 'value');  // Vezi valoarea Ã®n console

  return (
    <div>
      <hr />
      <button onClick={handleClick}>Clicked: {value}</button>
    </div>
  );
}
```

**Scenariul pas cu pas:**

**Primul render (Ã®ncÄƒrcare iniÈ›ialÄƒ):**
```
1. React apeleazÄƒ State()
2. useState(0) creeazÄƒ state cu valoarea 0
3. value = 0
4. Console: "0 value"
5. Pe ecran: "Clicked: 0"
```

**Dai primul click:**
```
1. User dÄƒ click
2. React apeleazÄƒ handleClick()
3. handleClick apeleazÄƒ setValue(0 + 1) â†’ setValue(1)
4. React: "State schimbat! Redesenez!"
5. React apeleazÄƒ din nou State()
6. value = 1 (React Ã®È™i aminteÈ™te noua valoare)
7. Console: "1 value"
8. Pe ecran: "Clicked: 1"
```

**Dai al doilea click:**
```
1. User dÄƒ click
2. React apeleazÄƒ handleClick()
3. handleClick apeleazÄƒ setValue(1 + 1) â†’ setValue(2)
4. React: "State schimbat! Redesenez!"
5. React apeleazÄƒ din nou State()
6. value = 2
7. Console: "2 value"
8. Pe ecran: "Clicked: 2"
```

### ğŸ“Š Vizualizare completÄƒ

```
RENDER INIÈšIAL:
â”œâ”€ React apeleazÄƒ State()
â”œâ”€ useState(0) â†’ value = 0, setValue = funcÈ›ie
â”œâ”€ console.log â†’ "0 value"
â””â”€ Return: <button>Clicked: 0</button>

USER DÄ‚ CLICK #1:
â”œâ”€ Browser detecteazÄƒ click
â”œâ”€ React apeleazÄƒ handleClick()
â”œâ”€ handleClick apeleazÄƒ setValue(1)
â””â”€ React: "Redesenez!"

RE-RENDER #1:
â”œâ”€ React apeleazÄƒ State()
â”œâ”€ useState returneazÄƒ value = 1
â”œâ”€ console.log â†’ "1 value"
â””â”€ Browser actualizeazÄƒ: "Clicked: 1"

USER DÄ‚ CLICK #2:
â”œâ”€ React apeleazÄƒ handleClick()
â”œâ”€ handleClick apeleazÄƒ setValue(2)
â””â”€ React: "Redesenez!"

RE-RENDER #2:
â”œâ”€ React apeleazÄƒ State()
â”œâ”€ useState returneazÄƒ value = 2
â”œâ”€ console.log â†’ "2 value"
â””â”€ Browser actualizeazÄƒ: "Clicked: 2"
```

### ğŸ¯ Reguli importante pentru useState

#### 1. State-ul e privat pentru fiecare componentÄƒ

```jsx
<State />  // Are propriul sÄƒu value = 0
<State />  // Are propriul sÄƒu value = 0 (diferit de primul!)
<State />  // Are propriul sÄƒu value = 0 (diferit de primele douÄƒ!)
```

**Fiecare componentÄƒ are propria memorie, separatÄƒ de celelalte!**

**Analogie:** E ca trei case diferite. Fiecare casÄƒ are propriul sÄƒu Ã®ntrerupÄƒtor de luminÄƒ. CÃ¢nd apeÈ™i Ã®ntrerupÄƒtorul Ã®n Casa 1, luminile din Casa 2 È™i Casa 3 nu se schimbÄƒ!

#### 2. Nu modifica state-ul direct!

```jsx
// âŒ GREÈ˜IT - Nu face aÈ™a:
value = value + 1;

// âœ… CORECT - FoloseÈ™te funcÈ›ia setter:
setValue(value + 1);
```

**De ce?**
- Modificarea directÄƒ nu anunÈ›Äƒ React-ul
- React nu va redesena componenta
- E ca È™i cum ai schimba mobilele Ã®n camerÄƒ pe Ã®ntuneric - nimeni nu vede!

**ComparaÈ›ie:**

```jsx
// Varianta GREÈ˜ITÄ‚:
let value = 0;
function handleClick() {
  value = value + 1;  // Se schimbÄƒ Ã®n memorie
  console.log(value); // AfiÈ™eazÄƒ 1, 2, 3...
}
// Rezultat: Console afiÈ™eazÄƒ corect, dar pe ecran rÄƒmÃ¢ne 0

// Varianta CORECTÄ‚:
const [value, setValue] = useState(0);
function handleClick() {
  setValue(value + 1);  // AnunÈ›Äƒ React-ul
}
// Rezultat: È˜i console È™i ecranul se actualizeazÄƒ corect
```

#### 3. Hook-urile se apeleazÄƒ doar la top-level

```jsx
// âœ… CORECT:
function State() {
  const [value, setValue] = useState(0);
  // restul codului
}

// âŒ GREÈ˜IT - Nu pune useState Ã®n if, for, sau alte funcÈ›ii:
function State() {
  if (condition) {
    const [value, setValue] = useState(0);  // NU FACE ASTA!
  }
}
```

**De ce?**
- React se bazeazÄƒ pe ordinea Ã®n care sunt apelate hook-urile
- DacÄƒ pui hook-uri Ã®n if/for, ordinea se schimbÄƒ â†’ React se confundÄƒ

### ğŸ¨ Exemplu practic complet

```jsx
import { useState } from "react";

export function Counter() {
  // State-ul: stocheazÄƒ numÄƒrul de click-uri
  const [count, setCount] = useState(0);

  // FuncÈ›ie care creÈ™te numÄƒrul
  function increment() {
    setCount(count + 1);
  }

  // FuncÈ›ie care scade numÄƒrul
  function decrement() {
    setCount(count - 1);
  }

  // FuncÈ›ie care reseteazÄƒ la 0
  function reset() {
    setCount(0);
  }

  return (
    <div style={{ padding: "20px" }}>
      <h2>Counter: {count}</h2>
      
      <button onClick={increment}>+1</button>
      <button onClick={decrement}>-1</button>
      <button onClick={reset}>Reset</button>
    </div>
  );
}
```

**Ce se Ã®ntÃ¢mplÄƒ aici:**

1. **State iniÈ›ial:** `count = 0`
2. **User dÄƒ click pe "+1":**
   - React apeleazÄƒ `increment()`
   - `increment` apeleazÄƒ `setCount(0 + 1)` â†’ `setCount(1)`
   - React redeseneazÄƒ â†’ `count = 1`
3. **User dÄƒ click pe "+1" din nou:**
   - React apeleazÄƒ `increment()`
   - `increment` apeleazÄƒ `setCount(1 + 1)` â†’ `setCount(2)`
   - React redeseneazÄƒ â†’ `count = 2`
4. **User dÄƒ click pe "Reset":**
   - React apeleazÄƒ `reset()`
   - `reset` apeleazÄƒ `setCount(0)`
   - React redeseneazÄƒ â†’ `count = 0`

---

## ğŸ¯ Recapitulare

### 1. Stilizare

**FoloseÈ™te `className` pentru clase È™i `style` (obiect) pentru CSS dinamic.**

```jsx
<div className="container" style={{ backgroundColor: "red" }}>
  ConÈ›inut
</div>
```

**De reÈ›inut:**
- `class` â†’ `className`
- `for` â†’ `htmlFor`
- `style` = obiect JavaScript
- ProprietÄƒÈ›i CSS Ã®n camelCase: `background-color` â†’ `backgroundColor`

### 2. Evenimente

**Atribute directe pe elemente: `onClick`, `onChange`, `onSubmit`**

```jsx
<button onClick={handleClick}>Click</button>
<input onChange={handleChange} />
```

**De reÈ›inut:**
- Adio `addEventListener`!
- Evenimente direct pe JSX: `onClick={funcÈ›ie}`
- Trimite REFERINÈšA funcÈ›iei (fÄƒrÄƒ paranteze)
- React apeleazÄƒ funcÈ›ia automat
- `event.target.value` pentru a citi input-ul

### 3. State

**`useState` = memoria componentei. SchimbÄƒ state-ul â†’ React redeseneazÄƒ automat**

```jsx
import { useState } from "react";

const [value, setValue] = useState(0);
setValue(value + 1);  // React redeseneazÄƒ!
```

**De reÈ›inut:**
- `useState` e un hook (Ã®ncepe cu `use`)
- ReturneazÄƒ array: `[valoare, setterFunction]`
- FoloseÈ™te destructuring pentru a extrage
- Nu modifica state-ul direct!
- Fiecare componentÄƒ are propriul state

### ğŸ“Š Tabel comparativ

| Concept | HTML/JS Vanilla | React |
|---------|-----------------|-------|
| **CSS Class** | `class="box"` | `className="box"` |
| **Label For** | `for="input1"` | `htmlFor="input1"` |
| **Inline Style** | `style="color: red"` | `style={{ color: "red" }}` |
| **Click Event** | `addEventListener("click")` | `onClick={handleClick}` |
| **Input Change** | `addEventListener("change")` | `onChange={handleChange}` |
| **State Management** | `let value = 0` (static) | `useState(0)` (reactive) |

### ğŸ’¡ GlumÄƒ de final

**De ce programatorii React nu merg la petreceri?**

Pentru cÄƒ nu le place sÄƒ-È™i schimbe state-ul prea des! ğŸ˜„

---

## ğŸ‰ FelicitÄƒri!

Acum È™tii:
- âœ… Cum sÄƒ stilizezi componente cu `className` È™i `style`
- âœ… Cum sÄƒ gestionezi evenimente Ã®n React
- âœ… Ce este `useState` È™i cum transformÄƒ componente statice Ã®n interactive
- âœ… Cine apeleazÄƒ ce È™i cÃ¢nd (spoiler: React face magia!)

**UrmÄƒtorul pas:** ExerseazÄƒ creÃ¢nd componente interactive cu state È™i evenimente! ğŸš€

---