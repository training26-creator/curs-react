# React: randarea listei È™i useEffect

> ÃnvaÈ›Äƒ cum sÄƒ transformi date Ã®n liste vizuale, cum sÄƒ filtrezi È™i cum sÄƒ foloseÈ™ti useEffect

---

## ğŸ“š Cuprins

1. [Ce face funcÈ›ia map()?](#-ce-face-funcÈ›ia-map)
2. [Randarea listelor cu map()](#-randarea-listelor-cu-map)
3. [Array Methods: filter(), concat(), map()](#-array-methods-filter-concat-map)
4. [Randarea condiÈ›ionatÄƒ](#-randarea-condiÈ›ionatÄƒ)
5. [useEffect - Sincronizarea magicÄƒ](#-useeffect---sincronizarea-magicÄƒ)
6. [ExerciÈ›iu practic: Todo List](#-exerciÈ›iu-practic-todo-list)

---

## ğŸŒ Ce face funcÈ›ia map()?

### text â†’ obiect todo

**Problema:** Ai un array cu text simplu:

```javascript
const sarciniRaw = ["ÃnvaÈ›Äƒ React", "FÄƒ cumpÄƒrÄƒturi", "Dormi puÈ›in"];
```

**Vrei:** SÄƒ transformi fiecare text Ã®ntr-un obiect mai complex:

```javascript
[
  { title: "ÃnvaÈ›Äƒ React", completed: false, id: 1 },
  { title: "FÄƒ cumpÄƒrÄƒturi", completed: false, id: 2 },
  { title: "Dormi puÈ›in", completed: false, id: 3 }
]
```

**SoluÈ›ia:** FuncÈ›ia `map()`!

```javascript
const sarciniRaw = ["ÃnvaÈ›Äƒ React", "FÄƒ cumpÄƒrÄƒturi", "Dormi puÈ›in"];

const todos = sarciniRaw.map((text, index) => {
  return {
    title: text,
    completed: false,
    id: index + 1
  };
});

console.log(todos);
// Rezultat: array de obiecte cu proprietÄƒÈ›i title, completed, id
```

### Ce face map()?

**map() = transformÄƒ date Ã®n elemente vizuale**

**Analogie:** E ca o fabricÄƒ - bagi materie primÄƒ (text) È™i scoÈ›i produse finite (obiecte sau componente React)!

**Reguli importante:**

1. **NU modificÄƒ array-ul original**
   ```javascript
   const original = [1, 2, 3];
   const dublat = original.map(num => num * 2);
   
   console.log(original); // [1, 2, 3] - neschimbat!
   console.log(dublat);   // [2, 4, 6] - nou array!
   ```

2. **ReturneazÄƒ ÃNTOTDEAUNA un array nou**
   ```javascript
   const numere = [1, 2, 3];
   const rezultat = numere.map(num => num * 2);
   // rezultat = [2, 4, 6] (array nou)
   ```

3. **Lungimea rÄƒmÃ¢ne aceeaÈ™i**
   ```javascript
   const input = [1, 2, 3];      // 3 elemente
   const output = input.map(...); // tot 3 elemente
   ```

---

## ğŸ¨ Randarea listelor cu map()

### De ce avem nevoie de map()?

**FÄƒrÄƒ map() (manual, greoi):**

```jsx
<ul>
  <li>ÃnvaÈ›Äƒ React</li>
  <li>FÄƒ cumpÄƒrÄƒturi</li>
  <li>Dormi puÈ›in</li>
</ul>
```

**ProblemÄƒ:** DacÄƒ ai 100 de task-uri? Scrii 100 de linii de cod?! ğŸ˜±

**Cu map() (dinamic, elegant):**

```jsx
const todos = ["ÃnvaÈ›Äƒ React", "FÄƒ cumpÄƒrÄƒturi", "Dormi puÈ›in"];

<ul>
  {todos.map((todo) => {
    return <li>{todo}</li>;
  })}
</ul>
```

**Rezultat:** 3 elemente `<li>` generate automat! DacÄƒ adaugi un al 4-lea todo, apare automat!

### key={index || id}

**AjutÄƒ React sÄƒ urmÄƒreascÄƒ fiecare element**

**De ce avem nevoie de `key`?**

CÃ¢nd randezi o listÄƒ, React trebuie sÄƒ È™tie CARE element este CARE. FÄƒrÄƒ `key`, React se confundÄƒ cÃ¢nd:
- È˜tergi un element
- Adaugi un element nou
- Reordonezi lista

**Analogie:** E ca numerele de pe locurile din avion - ajutÄƒ sÄƒ È™tii exact unde stai!

**Exemplu GREÈ˜IT (fÄƒrÄƒ key):**

```jsx
{todos.map((todo) => {
  return <li>{todo.title}</li>;  // âŒ Warning Ã®n console!
})}
```

**Exemplu CORECT (cu key):**

```jsx
{todos.map((todo) => {
  return <li key={todo.id}>{todo.title}</li>;  // âœ… Perfect!
})}
```

**Ce foloseÈ™ti ca key:**

1. **ID unic** (cel mai bun) - din bazÄƒ de date sau generat
   ```jsx
   <li key={todo.id}>{todo.title}</li>
   ```

2. **Index** (doar dacÄƒ lista nu se modificÄƒ niciodatÄƒ)
   ```jsx
   {todos.map((todo, index) => {
     return <li key={index}>{todo.title}</li>;
   })}
   ```

**âš ï¸ AtenÈ›ie:** Nu folosi index ca key dacÄƒ lista se modificÄƒ (adaugi/È™tergi/reordonezi)!

### `<element>` dinamic

**Array-ul devine o listÄƒ pe ecran**

```jsx
const todos = [
  { id: 1, title: "Buy Groceries", completed: false },
  { id: 2, title: "Call Mom", completed: false },
  { id: 3, title: "Finish Report", completed: true }
];

// TransformÄƒm array-ul Ã®n elemente <li>
<ul className="todo-list">
  {todos.map((todo) => {
    return (
      <li key={todo.id} className="todo-item">
        <span>{todo.title}</span>
      </li>
    );
  })}
</ul>
```

**Ce se Ã®ntÃ¢mplÄƒ:**

```
1. React vede todos.map()
   â†“
2. Pentru fiecare todo din array:
   - todo = { id: 1, title: "Buy Groceries", completed: false }
   - CreeazÄƒ: <li key={1}><span>Buy Groceries</span></li>
   â†“
3. Rezultat final (Ã®n DOM):
   <ul>
     <li key={1}><span>Buy Groceries</span></li>
     <li key={2}><span>Call Mom</span></li>
     <li key={3}><span>Finish Report</span></li>
   </ul>
```

---

## ğŸ”§ Array Methods: filter(), concat(), map()

### 1. map() - TransformÄƒ fiecare element

**Folosire:** CÃ¢nd vrei sÄƒ MODIFICI fiecare element din array.

```javascript
const numere = [1, 2, 3];
const dublat = numere.map(num => num * 2);

console.log(dublat); // [2, 4, 6]
```

**Ãn Todo List - MarcheazÄƒ ca terminat:**

```javascript
const todos = [
  { id: 1, title: "ÃnvaÈ›Äƒ", completed: false },
  { id: 2, title: "MÄƒnÃ¢ncÄƒ", completed: false }
];

// MarcheazÄƒ todo cu id=1 ca terminat
const updated = todos.map((todo) => {
  if (todo.id === 1) {
    todo.completed = !todo.completed;  // schimbÄƒ false â†’ true
  }
  return todo;
});

console.log(updated);
// [
//   { id: 1, title: "ÃnvaÈ›Äƒ", completed: true },  â† SCHIMBAT!
//   { id: 2, title: "MÄƒnÃ¢ncÄƒ", completed: false }
// ]
```

**Din codul nostru:**

```javascript
function handleComplete(id) {
  const updated = todos.map((todo) => {
    if (todo.id === id) todo.completed = !todo.completed;
    return todo;
  });
  setTodos(updated);
}
```

**Fluxul complet:**

```
1. User bifeazÄƒ checkbox-ul la "ÃnvaÈ›Äƒ React" (id: 1)
   â†“
2. React apeleazÄƒ handleComplete(1)
   â†“
3. map() parcurge fiecare todo:
   - todo.id === 1? DA â†’ todo.completed = !false â†’ true
   - todo.id === 2? NU â†’ rÄƒmÃ¢ne neschimbat
   â†“
4. setTodos(updated) â†’ React redeseneazÄƒ
   â†“
5. Checkbox-ul apare bifat, textul tÄƒiat
```

### 2. filter() - EliminÄƒ dupÄƒ criteriu

**Folosire:** CÃ¢nd vrei sÄƒ ELIMINI elemente care NU Ã®ndeplinesc o condiÈ›ie.

```javascript
const numere = [1, 2, 3, 4, 5];
const pereNumai = numere.filter(num => num % 2 === 0);

console.log(pereNumai); // [2, 4]
```

**Ãn Todo List - È˜terge task:**

```javascript
const todos = [
  { id: 1, title: "ÃnvaÈ›Äƒ" },
  { id: 2, title: "MÄƒnÃ¢ncÄƒ" },
  { id: 3, title: "Dormi" }
];

// È˜terge todo cu id=2
const updated = todos.filter((todo) => todo.id !== 2);

console.log(updated);
// [
//   { id: 1, title: "ÃnvaÈ›Äƒ" },
//   { id: 3, title: "Dormi" }
// ]
// Todo cu id=2 a DISPÄ‚RUT!
```

**Din codul nostru:**

```javascript
function handleDelete(id) {
  const updated = todos.filter((todo) => todo.id !== id);
  setTodos(updated);
}
```

**Fluxul complet:**

```
1. User dÄƒ click pe "Sterge" la "Call Mom" (id: 2)
   â†“
2. React apeleazÄƒ handleDelete(2)
   â†“
3. filter() parcurge fiecare todo:
   - todo.id !== 2? 
     â€¢ id: 1 â†’ 1 !== 2? DA â†’ PÄ‚STREAZÄ‚
     â€¢ id: 2 â†’ 2 !== 2? NU â†’ ELIMINÄ‚
     â€¢ id: 3 â†’ 3 !== 2? DA â†’ PÄ‚STREAZÄ‚
   â†“
4. Rezultat: [todo1, todo3] (fÄƒrÄƒ todo2!)
   â†“
5. setTodos(updated) â†’ React redeseneazÄƒ
   â†“
6. "Call Mom" dispare din listÄƒ
```

### 3. concat() - AdaugÄƒ element

**Folosire:** CÃ¢nd vrei sÄƒ ADAUGI elemente la array fÄƒrÄƒ sÄƒ modifici originalul.

```javascript
const original = [1, 2, 3];
const nou = original.concat(4);

console.log(original); // [1, 2, 3] - neschimbat!
console.log(nou);      // [1, 2, 3, 4] - nou array!
```

**Alternativa GREÈ˜ITÄ‚ (modificÄƒ array-ul original):**

```javascript
// âŒ NU FACE ASTA ÃN REACT:
const todos = [todo1, todo2];
todos.push(newTodo);  // ModificÄƒ array-ul direct - React NU detecteazÄƒ!
```

**Alternativa CORECTÄ‚ (creeazÄƒ array nou):**

```javascript
// âœ… CORECT - React detecteazÄƒ schimbarea:
const todos = [todo1, todo2];
const updated = todos.concat(newTodo);  // Array NOU!
setTodos(updated);
```

**Din codul nostru:**

```javascript
function handleAdd() {
  const newTodo = {
    title: inputValue,
    completed: false,
    id: Date.now()
  };

  // âŒ GREÈ˜IT:
  // todos.push(newTodo);

  // âœ… CORECT:
  setTodos(todos.concat(newTodo));
  setInputValue("");
}
```

**Fluxul complet:**

```
1. User scrie "ÃnvaÈ›Äƒ React" Ã®n input
   â†“
2. User dÄƒ click pe "Adauga"
   â†“
3. React apeleazÄƒ handleAdd()
   â†“
4. CreeazÄƒ obiect newTodo:
   {
     title: "ÃnvaÈ›Äƒ React",
     completed: false,
     id: 1738368000000
   }
   â†“
5. concat() creeazÄƒ array NOU:
   [todo1, todo2, newTodo]
   â†“
6. setTodos(updated) â†’ React detecteazÄƒ schimbarea
   â†“
7. React redeseneazÄƒ componenta
   â†“
8. "ÃnvaÈ›Äƒ React" apare Ã®n listÄƒ
   â†“
9. setInputValue("") â†’ input-ul se goleÈ™te
```

### ğŸ“Š ComparaÈ›ie rapidÄƒ

| Method | Ce face? | ModificÄƒ originalul? | Exemplu |
|--------|----------|---------------------|---------|
| **map()** | TransformÄƒ fiecare element | âŒ NU | `[1,2,3].map(x => x*2)` â†’ `[2,4,6]` |
| **filter()** | EliminÄƒ elemente | âŒ NU | `[1,2,3].filter(x => x>1)` â†’ `[2,3]` |
| **concat()** | AdaugÄƒ la sfÃ¢rÈ™it | âŒ NU | `[1,2].concat(3)` â†’ `[1,2,3]` |
| **push()** | AdaugÄƒ la sfÃ¢rÈ™it | âœ… DA | `arr.push(3)` â†’ modificÄƒ `arr` |

**Regula de AUR Ã®n React:** FoloseÈ™te doar metode care **NU modificÄƒ** array-ul original (map, filter, concat)!

---

## ğŸ”€ Randarea condiÈ›ionatÄƒ

### Ce este?

**UI-ul inteligent care se adapteazÄƒ situaÈ›iei**

**Analogie:** Ca un semafor - roÈ™u = stai, verde = treci. Codul decide ce sÄƒ afiÈ™eze!

### ListÄƒ goalÄƒ?

**FoloseÈ™te `if` Ã®nainte de return pentru a afiÈ™a un mesaj prietenos**

```jsx
export function Todos() {
  const [todos, setTodos] = useState([]);

  if (todos.length === 0) {
    return <p>Hey nu ai de facut nimic</p>;
  }

  return (
    <ul>
      {todos.map((todo) => (
        <li key={todo.id}>{todo.title}</li>
      ))}
    </ul>
  );
}
```

**Ce se Ã®ntÃ¢mplÄƒ:**

```
1. React apeleazÄƒ Todos()
   â†“
2. VerificÄƒ: todos.length === 0?
   â†“
3. DA â†’ return <p>Hey nu ai de facut nimic</p>
   (restul codului NU se executÄƒ!)
   â†“
4. Browser afiÈ™eazÄƒ: "Hey nu ai de facut nimic"
```

### Task bifat?

**Operatorul ternar `? :` Ã®n JSX**

**SintaxÄƒ:**
```javascript
conditie ? valoare_daca_adevarat : valoare_daca_fals
```

**Exemplu simplu:**

```javascript
const varsta = 18;
const mesaj = varsta >= 18 ? "EÈ™ti adult" : "EÈ™ti minor";
console.log(mesaj); // "EÈ™ti adult"
```

**Ãn codul nostru:**

```jsx
<span className={todo.completed ? "text-done" : ""}>
  {todo.title}
</span>
```

**ExplicaÈ›ie:**

```
1. VerificÄƒ: todo.completed este true sau false?
   â†“
2. DacÄƒ todo.completed === true:
   â†’ className="text-done" (text tÄƒiat)
   â†“
3. DacÄƒ todo.completed === false:
   â†’ className="" (text normal)
```

**Vizual:**

```css
/* Ãn CSS: */
.text-done {
  text-decoration: line-through;
  color: gray;
}
```

```
completed: false â†’ "ÃnvaÈ›Äƒ React" (normal)
completed: true  â†’ "ÃnvaÈ›Äƒ React" (tÄƒiat È™i gri)
```

### Randare condiÈ›ionatÄƒ cu `&&`

**Din codul nostru:**

```jsx
{todos.length === 0 && <p>Hey nu ai de facut nimic</p>}
```

**Cum funcÈ›ioneazÄƒ `&&` Ã®n JSX:**

```
conditie && element_JSX
```

- DacÄƒ `conditie` este `true` â†’ afiÈ™eazÄƒ `element_JSX`
- DacÄƒ `conditie` este `false` â†’ nu afiÈ™eazÄƒ nimic

**Exemplu pas cu pas:**

```jsx
// CÃ¢nd todos = []
todos.length === 0 && <p>Hey nu ai de facut nimic</p>
// 0 === 0 â†’ true && <p> â†’ AFIÈ˜EAZÄ‚ <p>

// CÃ¢nd todos = [todo1, todo2]
todos.length === 0 && <p>Hey nu ai de facut nimic</p>
// 2 === 0 â†’ false && <p> â†’ NU AFIÈ˜EAZÄ‚ NIMIC
```

**ComparaÈ›ie `if` vs `&&`:**

```jsx
// Varianta 1: if Ã®nainte de return
if (todos.length === 0) {
  return <p>Hey nu ai de facut nimic</p>;
}

// Varianta 2: && Ã®n JSX
{todos.length === 0 && <p>Hey nu ai de facut nimic</p>}
```

**DiferenÈ›a:**
- `if` Ã®nainte de return â†’ opreÈ™te TOATÄ‚ componenta
- `&&` Ã®n JSX â†’ afiÈ™eazÄƒ doar partea aia condiÈ›ionat

---

## â° useEffect - Sincronizarea magicÄƒ

### Ce este useEffect?

**State-ul e ca un Ã®ntrerupÄƒtor de luminÄƒ: poate fi pornit sau oprit.**

**useEffect e ca alarma telefonului â€” setezi cÃ¢nd sÄƒ sune È™i ce sÄƒ facÄƒ.**

### Array gol []

**RuleazÄƒ o singurÄƒ datÄƒ la Ã®ncÄƒrcare**

**Exemplu: date de la API**

```jsx
import { useEffect, useState } from "react";

export function Todos() {
  const [todos, setTodos] = useState([]);

  useEffect(() => {
    console.log("Componenta s-a Ã®ncÄƒrcat!");
  }, []);

  return <div>Todo List</div>;
}
```

**Fluxul complet:**

```
1. React apeleazÄƒ Todos() prima datÄƒ
   â†“
2. useState([]) â†’ todos = []
   â†“
3. React vede useEffect cu []
   â†“
4. React: "Ok, executez asta DOAR PRIMA DATÄ‚"
   â†“
5. Console: "Componenta s-a Ã®ncÄƒrcat!"
   â†“
6. Return: <div>Todo List</div>
   â†“
7. User dÄƒ click pe ceva â†’ componenta se redeseneazÄƒ
   â†“
8. useEffect NU se mai executÄƒ (pentru cÄƒ [])
```

**CÃ¢nd se foloseÈ™te:**

- Cereri la API (fetch date la Ã®ncÄƒrcare)
- SetÄƒri iniÈ›iale (de ex. localStorage)
- Conectare la servicii externe

**Analogie:** E ca un `onload` - se executÄƒ o singurÄƒ datÄƒ cÃ¢nd pagina se Ã®ncarcÄƒ!

### Cu dependenÈ›e [todos]

**RuleazÄƒ cÃ¢nd lista se schimbÄƒ**

**Exemplu: salvare automatÄƒ**

```jsx
import { useEffect, useState } from "react";

export function Todos() {
  const [todos, setTodos] = useState([]);

  useEffect(() => {
    console.log("todos a fost modificat", todos);
  }, [todos]);

  return <div>Todo List</div>;
}
```

**Fluxul complet:**

```
RENDER INIÈšIAL:
1. React apeleazÄƒ Todos()
   â†“
2. useState([]) â†’ todos = []
   â†“
3. useEffect verificÄƒ: [todos] s-a schimbat?
   â†’ DA (prima datÄƒ se considerÄƒ schimbare)
   â†“
4. Console: "todos a fost modificat []"

USER ADAUGÄ‚ TODO:
5. handleAdd() â†’ setTodos([newTodo])
   â†“
6. React redeseneazÄƒ componenta
   â†“
7. useEffect verificÄƒ: [todos] s-a schimbat?
   â†’ DA (era [], acum e [newTodo])
   â†“
8. Console: "todos a fost modificat [newTodo]"

USER ADAUGÄ‚ AL DOILEA TODO:
9. handleAdd() â†’ setTodos([todo1, todo2])
   â†“
10. React redeseneazÄƒ
   â†“
11. useEffect verificÄƒ: [todos] s-a schimbat?
   â†’ DA (era [todo1], acum e [todo1, todo2])
   â†“
12. Console: "todos a fost modificat [todo1, todo2]"
```

**CÃ¢nd se foloseÈ™te:**

- Salvare automatÄƒ Ã®n localStorage
- Sincronizare cu server
- Validare dupÄƒ modificare
- CalculÄƒri complexe bazate pe state

**Analogie:** E ca un senzor de miÈ™care - detecteazÄƒ cÃ¢nd `todos` se modificÄƒ È™i reacÈ›ioneazÄƒ!

### ğŸ“Š ComparaÈ›ie tipuri de useEffect

| DependenÈ›e | CÃ¢nd se executÄƒ | Exemplu folosire |
|------------|-----------------|------------------|
| **FÄƒrÄƒ array** | La fiecare render | âŒ Rareori folosit - creeazÄƒ probleme |
| **[] gol** | O singurÄƒ datÄƒ (la montare) | API fetch, setup iniÈ›ial |
| **[state]** | CÃ¢nd `state` se schimbÄƒ | Salvare automatÄƒ, sincronizare |

---

## ğŸ“ ExerciÈ›iu practic: Todo List

### Codul complet explicat

```jsx
import { useEffect, useState } from "react";
import "./todos.css";

export function Todos() {
  // STATE: lista de todo-uri
  const [todos, setTodos] = useState([]);
  
  // STATE: valoarea din input
  const [inputValue, setInputValue] = useState("");

  console.log(todos, "modificat");

  // useEffect #1: Se executÄƒ DOAR la Ã®ncÄƒrcare
  useEffect(() => {
    console.log("Componenta s-a Ã®ncÄƒrcat!");
  }, []);

  // useEffect #2: Se executÄƒ cÃ¢nd todos se modificÄƒ
  useEffect(() => {
    console.log("todos a fost modificat", todos);
  }, [todos]);

  // HANDLER: ActualizeazÄƒ inputValue cÃ¢nd user scrie
  function handleInputChange(event) {
    setInputValue(event.target.value);
  }

  // HANDLER: AdaugÄƒ un todo nou
  function handleAdd() {
    const newTodo = {
      title: inputValue,
      completed: false,
      id: Date.now()
    };

    // âœ… CORECT: concat creeazÄƒ array NOU
    setTodos(todos.concat(newTodo));
    
    // GoleÈ™te input-ul
    setInputValue("");
  }

  // HANDLER: È˜terge un todo
  function handleDelete(id) {
    // filter ELIMINÄ‚ todo-ul cu id-ul specificat
    const updated = todos.filter((todo) => todo.id !== id);
    setTodos(updated);
  }

  // HANDLER: MarcheazÄƒ todo ca terminat/neterminat
  function handleComplete(id) {
    // map MODIFICÄ‚ todo-ul cu id-ul specificat
    const updated = todos.map((todo) => {
      if (todo.id === id) {
        todo.completed = !todo.completed;
      }
      return todo;
    });
    setTodos(updated);
  }

  return (
    <div className="todo-container">
      <h1>Todo List</h1>

      <div className="input-group">
        <input 
          type="text" 
          value={inputValue} 
          onChange={handleInputChange} 
        />
        <button className="add-btn" onClick={handleAdd}>
          Adauga
        </button>
      </div>

      {/* Randare condiÈ›ionatÄƒ: afiÈ™eazÄƒ mesaj dacÄƒ lista e goalÄƒ */}
      {todos.length === 0 && <p>Hey nu ai de facut nimic</p>}

      {/* Lista de todo-uri */}
      <ul className="todo-list">
        {todos.map((todo) => {
          return (
            <li key={todo.id} className="todo-item">
              <div>
                <input
                  type="checkbox"
                  checked={todo.completed}
                  onChange={() => handleComplete(todo.id)}
                />
                
                {/* Operatorul ternar: text tÄƒiat dacÄƒ completed=true */}
                <span className={todo.completed ? "text-done" : ""}>
                  {todo.title}
                </span>
              </div>

              <button
                className="delete-btn"
                onClick={() => handleDelete(todo.id)}
              >
                Sterge
              </button>
            </li>
          );
        })}
      </ul>
    </div>
  );
}
```

### Fluxul complet al aplicaÈ›iei

```
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                    ÃNCÄ‚RCARE INIÈšIALÄ‚                     â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

1. React apeleazÄƒ Todos()
   â†“
2. useState([]) â†’ todos = []
   useState("") â†’ inputValue = ""
   â†“
3. console.log(todos, "modificat") â†’ "[] modificat"
   â†“
4. useEffect(() => {...}, []) 
   â†’ Console: "Componenta s-a Ã®ncÄƒrcat!"
   â†“
5. useEffect(() => {...}, [todos])
   â†’ Console: "todos a fost modificat []"
   â†“
6. Return JSX
   â†“
7. Ecran:
   - Titlu: "Todo List"
   - Input gol
   - Mesaj: "Hey nu ai de facut nimic"


â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘              USER SCRIE "ÃnvaÈ›Äƒ React"                    â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

1. User tasteazÄƒ "Ã"
   â†“
2. onChange declanÈ™at â†’ handleInputChange(event)
   â†“
3. event.target.value = "Ã"
   â†“
4. setInputValue("Ã")
   â†“
5. React redeseneazÄƒ
   â†“
6. Input afiÈ™eazÄƒ: "Ã"

(Se repetÄƒ pentru fiecare literÄƒ: "Ãa", "Ãnv", etc.)


â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                USER DÄ‚ CLICK "Adauga"                     â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

1. onClick declanÈ™at â†’ handleAdd()
   â†“
2. CreeazÄƒ newTodo:
   {
     title: "ÃnvaÈ›Äƒ React",
     completed: false,
     id: 1738368000000
   }
   â†“
3. todos.concat(newTodo)
   â†’ Array NOU: [newTodo]
   â†“
4. setTodos([newTodo])
   â†“
5. setInputValue("") â†’ goleÈ™te input-ul
   â†“
6. React redeseneazÄƒ
   â†“
7. console.log(todos, "modificat") 
   â†’ "[{...}] modificat"
   â†“
8. useEffect cu [todos] detecteazÄƒ schimbarea
   â†’ Console: "todos a fost modificat [{...}]"
   â†“
9. Ecran:
   - Input gol
   - âœ… Lista apare:
     â˜ ÃnvaÈ›Äƒ React [Sterge]


â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘            USER BIFEAZÄ‚ CHECKBOX-UL                       â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

1. onChange declanÈ™at â†’ handleComplete(1738368000000)
   â†“
2. todos.map parcurge fiecare todo:
   - todo.id === 1738368000000? DA
   - todo.completed = !false â†’ true
   â†“
3. setTodos(updated)
   â†“
4. React redeseneazÄƒ
   â†“
5. useEffect cu [todos] se executÄƒ
   â†“
6. Ecran:
   - â˜‘ ÃnvaÈ›Äƒ React (text tÄƒiat, gri)


â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘           USER DÄ‚ CLICK "Sterge"                          â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

1. onClick declanÈ™at â†’ handleDelete(1738368000000)
   â†“
2. todos.filter eliminÄƒ todo-ul:
   - todo.id !== 1738368000000? NU â†’ ELIMINÄ‚
   â†“
3. Rezultat: [] (array gol)
   â†“
4. setTodos([])
   â†“
5. React redeseneazÄƒ
   â†“
6. useEffect cu [todos] se executÄƒ
   â†“
7. Ecran:
   - Mesaj: "Hey nu ai de facut nimic"
```

### FuncÈ›iile onClick - DouÄƒ variante

**Din codul nostru, ai observat douÄƒ stiluri:**

```jsx
// Varianta 1: ReferinÈ›Äƒ directÄƒ (fÄƒrÄƒ parametri)
<button className="add-btn" onClick={handleAdd}>
  Adauga
</button>

// Varianta 2: FuncÈ›ie anonimÄƒ (cu parametri)
<button className="delete-btn" onClick={() => handleDelete(todo.id)}>
  Sterge
</button>
```

**De ce diferenÈ›a?**

**Varianta 1: CÃ¢nd NU ai nevoie de parametri**

```jsx
onClick={handleAdd}
```

- TrimiÈ›i REFERINÈšA funcÈ›iei direct
- React va apela `handleAdd()` cÃ¢nd user-ul dÄƒ click
- Nu trimiÈ›i parametri suplimentari

**Varianta 2: CÃ¢nd ai nevoie de parametri**

```jsx
onClick={() => handleDelete(todo.id)}
```

- Creezi o funcÈ›ie anonimÄƒ (arrow function)
- FuncÈ›ia anonimÄƒ apeleazÄƒ `handleDelete` cu parametrul `todo.id`
- React apeleazÄƒ funcÈ›ia anonimÄƒ la click
- FuncÈ›ia anonimÄƒ apeleazÄƒ `handleDelete(todo.id)`

**GreÈ™eala clasicÄƒ:**

```jsx
// âŒ GREÈ˜IT - apeleazÄƒ funcÈ›ia IMEDIAT:
<button onClick={handleDelete(todo.id)}>Sterge</button>

// âœ… CORECT - creeazÄƒ funcÈ›ie care va apela mai tÃ¢rziu:
<button onClick={() => handleDelete(todo.id)}>Sterge</button>
```

---

## ğŸ¯ Recapitulare

### 1. map() - TransformÄƒ array Ã®n JSX

```jsx
{todos.map((todo) => (
  <li key={todo.id}>{todo.title}</li>
))}
```

**De reÈ›inut:**
- TransformÄƒ date Ã®n elemente vizuale
- NU modificÄƒ array-ul original
- FoloseÈ™te `key` unic pentru fiecare element

### 2. Array Methods

| Method | Scop | ModificÄƒ originalul? |
|--------|------|---------------------|
| **map()** | TransformÄƒ | âŒ NU |
| **filter()** | EliminÄƒ | âŒ NU |
| **concat()** | AdaugÄƒ | âŒ NU |

### 3. Randare condiÈ›ionatÄƒ

```jsx
// if Ã®nainte de return
if (todos.length === 0) {
  return <p>Lista goalÄƒ</p>;
}

// && Ã®n JSX
{todos.length === 0 && <p>Lista goalÄƒ</p>}

// Operator ternar
<span className={completed ? "done" : ""}>{title}</span>
```

### 4. useEffect

```jsx
// O datÄƒ (la Ã®ncÄƒrcare)
useEffect(() => {
  console.log("ÃncÄƒrcat!");
}, []);

// CÃ¢nd state se schimbÄƒ
useEffect(() => {
  console.log("Todos schimbat:", todos);
}, [todos]);
```

---

## ğŸ‰ FelicitÄƒri!

Acum È™tii:
- âœ… Cum sÄƒ transformi date Ã®n liste cu `map()`
- âœ… Cum sÄƒ foloseÈ™ti `filter()` pentru È™tergere
- âœ… Cum sÄƒ foloseÈ™ti `concat()` pentru adÄƒugare
- âœ… Cum sÄƒ foloseÈ™ti randare condiÈ›ionatÄƒ
- âœ… Ce este `useEffect` È™i cÃ¢nd se foloseÈ™te
- âœ… Cum sÄƒ construieÈ™ti un Todo List complet funcÈ›ional

**UrmÄƒtorul pas:** ExerseazÄƒ construind propriile liste interactive! ğŸš€